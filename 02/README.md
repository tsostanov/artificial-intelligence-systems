# Лаба 2 — Онтология (Protege) + советчик «идеального хода»

В этой части мы:
1) Переносим базу знаний в онтологию (`hearthstone.owl`) — классы/свойства уже есть.
2) Реализуем **советчик хода** поверх Prolog‑движка (`advisor.pl`) — он перебирает легальные ходы и выбирает лучший по жадной оценке.

> По условиям лабы программу можно строить на БЗ **или** онтологии. Мы используем **БЗ (Prolog)** для вычислений, а онтологию — для визуализации/запросов и как основу доменной модели. При желании легко добавить мост онтология→правила (см. в конце).

---

## Установка и запуск советчика

1) Убедитесь, что рядом лежит ваш `hearthstone.pl` (из Лабы 1).
2) Подгрузите оба файла:
```prolog
swipl
?- [hearthstone, advisor].
```
3) Получить совет не применяя его:
```prolog
?- initial_state(S0), advise(S0).
% Совет: attack(1,1) / play(chillwind_yeti) / ...
% Оценка: <число>
% Причина: kill(1) / develop_board(Card) / face_damage(N) / ...
```
4) Получить совет и **применить** ход:
```prolog
?- initial_state(S0), advise_and_apply(S0, S1), display_game(S1).
```
5) Вписать советчик в ваш интерактивный цикл (`start/0`):
- Внутри `game_loop(State)` добавьте команду `advice.` которая делает `advise(State).`
- Добавьте `advice_apply.` для применения: вызывает `advise_and_apply(State, State1)` и продолжает цикл со `State1`.

---

## Как выбирается «лучший» ход

Советчик генерирует кандидаты:
- **play(Card)** — каждую разыгрываемую карту из руки (если хватает маны и стол не переполнен);
- **attack(AttIdx,TargetIdx)** — все атаки (по существу/в лицо), которые реально проходят через ваш `attack/4`;
- **end_turn** — как запасной вариант.

Для каждого результата он считает **оценку состояния**:
```
Score = 10 * (MyHealth - OppHealth)
      +  3 * (MyBoardAttack - OppBoardAttack)
      +  2 * (MyMinions - OppMinions)
      +  1 * (MyTaunts - OppTaunts)
      +  1 * (MyHand - OppHand).
```
И выбирает ход с **максимальным** `Score`.  
Теги‑объяснения: `develop_board(Card)`, `face_damage(Dmg)`, `kill(TargetIdx)`, `trade(TargetIdx)`, `pass_turn`.

> Это **жадный** (depth‑1) выбор. Для курсовой/лабы этого достаточно. Если хотите «сильнее», см. раздел «Расширения».

---

## Примеры запросов

```prolog
% Лучший ход из стартового состояния
?- initial_state(S0), best_move(S0, M, Score, Reason, S1).
M = play(chillwind_yeti) ;
% или другой ход, зависит от вашего initial_state

% Применить лучший ход и посмотреть позицию
?- initial_state(S0), advise_and_apply(S0, S1), display_game(S1).

% Прогнать два лучших хода подряд (псевдо-план)
?- initial_state(S0),
   advise_and_apply(S0, S1),
   advise_and_apply(S1, S2),
   display_game(S2).
```

---

## Как это связано с онтологией (Protege)

Онтология (`hearthstone.owl`) описывает:
- классы: `Card`, `Ability`, `Tribe`, `Player`, `GameState` и т.д.;
- object properties: `abilityOf`, `inHand`, `inDeck`, `inBoard`;
- data properties: `attack`, `health`, `mana`, `turn`;

Чтобы «подружить» reasoner с советчиком:
- В онтологии можно определить **правила угроз** (через SWRL) — например, миньон с `taunt`/`charge` → `HighThreat`.
- В Prolog добавить простой маппинг `high_threat(Name).` (или читать TTL и порождать факты), и давать бонус к оценке за убийство `HighThreat`.

Мини‑пример (в Prolog без подключения OWL):
```prolog
high_threat(Name) :- ability_of(Name, taunt).
high_threat(Name) :- ability_of(Name, charge).

% Затем в eval_state можно добавить вес за (OppHighThreatCount уменьшился).
```

---

## Расширения (если будет время)

1) **Проверка летала** на 1 глубину: если нет таунтов и сумма доступных атак ≥ HP оппонента — приоритизировать «в лицо».
2) **Лучший размен**: оценивать убийства по эффективности (сколько нашего статов теряется против сколько снимаем у врага). Сейчас мы учитываем это косвенно через общую оценку.
3) **Поиск на 2 полхода (минимакс)**: рассчитать ответ соперника с той же оценкой и выбрать ход, максимизирующий наш минимум.
4) **Учёт Rush/Charge точнее**: можно тестировать готовность не через поля миньона, а просто проверкой `attack/4` (как в коде).
5) **Ограничения стола**: если у вас нет — добавить лимит на 7 существ в `play_minion/3` (влияет на кандидаты).

---

## Частые вопросы

- *Почему не чисто на онтологии?*  
OWL/DL плохо подходит для «планирования действий» и оптимизации по utility. Онтология отлично задаёт **смысл** и позволяет делать выводы про классы/отношения, но «лучший ход» — это уже оптимизационная логика, которую удобнее реализовать в Prolog (или как гибрид OWL+правила).

- *Можно ли сделать объяснение «почему именно этот ход»?*  
Да: мы уже печатаем `Reason`. Можно расширить: например, при убийстве выводить имя цели и её атаку/способности.

Удачи на защите! Если хочешь — интегрирую советчик прямо в твой `start/0` и подготовлю демо‑скрипт команд.
